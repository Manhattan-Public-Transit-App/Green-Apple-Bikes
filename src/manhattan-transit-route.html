<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="shared-styles.html">
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDTl1JhIHmAfin_kXUBYCnAeIkudpJypcc&libraries=places"></script>

<dom-module id="manhattan-transit-route">
	<template>
	    <style include="shared-styles">
			:host {
				display: block;
				padding: 10px;
			}
    	</style>
    	<div class="card" style="display: flex">
			<paper-input id="origin" label="Starting Location" style="display: inline-block; width: 90%;"></paper-input>
			<paper-icon-button id="get-location" on-click="getOriginLocation" src="/images/get-location.png" style="margin-top: 15px;"></paper-icon-button>
		</div>
    	<div class="card">
			<paper-input id="destination" label="Destination" style="display: inline-block; width: 90%;"></paper-input>
			<paper-icon-button id="get-location" on-click="getDestinationLocation" src="/images/get-location.png" style="margin-top: 15px;"></paper-icon-button>
		</div>
    	<br><br>
    	<div class="card button-container">
			<paper-button id="submit" on-click="calculateRoute" raised>Determine Fastest Route</paper-button>
		</div>
    </template>
	<script>
		// Initialize Variables
		var destinationLatLong;
		var originLatLong;
		var originInput;
		var destinationInput;
		// If debugging, set this to true
		var debugging = true;
		Polymer({
			is: 'manhattan-transit-route',
			ready: function() {
				// The following sets up the google autocomplete location fields:
				originInput = this.$.origin.inputElement;
				originAutocomplete = new google.maps.places.Autocomplete(originInput);
				destinationInput = this.$.destination.inputElement;
				destinationAutocomplete = new google.maps.places.Autocomplete(destinationInput);

				// Whenever the inputs change, set the originLatLong and destinationLatLong
				google.maps.event.addListener(originAutocomplete, 'place_changed', function() {
					var place = originAutocomplete.getPlace();
					originLatLong = new google.maps.LatLng(place.geometry.location.lat(), place.geometry.location.lng());
				});
				google.maps.event.addListener(destinationAutocomplete, 'place_changed', function() {
					var place = destinationAutocomplete.getPlace();
					destinationLatLong = new google.maps.LatLng(place.geometry.location.lat(), place.geometry.location.lng());
				});
			},
			// This function is the function called by the button on the page.
			calculateRoute: function(e) {
				// Initialize values:
				var origin = this.$.origin.inputElement.value;
				var destination = this.$.destination.inputElement.value;

				// Get available bikes:
				var availableBikes = getBikes();
				if (availableBikes.length == 0) {
					alert("There are currently no bikes available.");
				}

				// Now let's find the time it takes to walk to the destination directly.
				var walkingTime;
				var bikingTime;
				// If we have an available bike
				if (availableBikes.length > 0) {
					// Let's check which bike is closest to the origin
					var theNearestBike = NearestBike(availableBikes, originLatLong.lat(), originLatLong.lng());
					// Create new LatLng with bike's location.
					var bikeLatLong = new google.maps.LatLng(theNearestBike.latitude,theNearestBike.longitude);

					Promise.all([findRoute(originLatLong, destinationLatLong, "walking"), findRoute(origin, bikeLatLong , "walking"), findRoute(bikeLatLong, destination, "bicycling")]).then(function(resultArray) {
						walkingTime = resultArray[0];
						bikingTime = resultArray[1];
						bikingTime += resultArray[2];
						if (debugging) {
							console.log("Inside Promise:");
							console.log("Walking time: " + walkingTime);
							console.log("Biking time: " + bikingTime);
						}
						if (bikingTime < walkingTime) {
							alert("Biking is faster. Routing you to nearest bike.");
							window.open("https://www.google.com/maps/dir/" + origin + "/" + bikeLatLong + "/" + destination + "/data=!4m2!4m1!3e1");
						} else {
							alert("Walking is faster. Routing you to destination.");
							window.open("https://www.google.com/maps/dir/" + origin + "/" + destination + "/data=!4m2!4m1!3e2");
						}
					}).catch(function(reason){console.log("Promise Failed:\n" + reason)});

				} else {
					walkingTime = findRoute(originLatLong, destinationLatLong, "walking");
					alert("No bikes available. Routing you to destination.");
					window.open("https://www.google.com/maps/dir/" + origin + "/" + destination + "/data=!4m2!4m1!3e2");
				}
			},
			// This function is the function called by the button on the page.
			getOriginLocation: function() {
				if (navigator.geolocation) {
					originInput.focus();
						originInput.value = "Getting current location... Please wait...";
						originInput.blur();
				navigator.geolocation.getCurrentPosition(setOriginPosition);
				} else {
					alert("Geolocation is not supported by this browser.");
				}
			},
			getDestinationLocation: function() {
				if (navigator.geolocation) {
					destinationInput.focus();
						destinationInput.value = "Getting current location... Please wait...";
						destinationInput.blur();
				navigator.geolocation.getCurrentPosition(setDestinationPosition);
				} else {
					alert("Geolocation is not supported by this browser.");
				}
			}
		});

		/*
		 *  Function to set the current position.
		 */
		function setOriginPosition(position) {
			originInput.value = position.coords.latitude + ", " + position.coords.longitude;
			originLatLong = new google.maps.LatLng(position.coords.latitude,position.coords.longitude);
		}

		/*
		 *  Function to set the current position.
		 */
		function setDestinationPosition(position) {
			destinationInput.value = position.coords.latitude + ", " + position.coords.longitude;
			destinationLatLong = new google.maps.LatLng(position.coords.latitude,position.coords.longitude);
		}

		/*
		 *  Function to get available bikes
		 */
		function getBikes() {
			var bikeRequest = new XMLHttpRequest();
			bikeRequest.open("GET", "http://129.130.82.141/index.php/api/getLocation", false);
			bikeRequest.send(null)
			var bikes = JSON.parse(bikeRequest.responseText);

			var availableBikes = [];

			bikes.forEach(function(bike) {
				//console.log("WARNING: CHECKING FOR TAKEN BIKES (TESTING)");
					if (bike.status != "Taken") {
					availableBikes.push(bike);
				}
			});
			if (debugging) { console.log("There are " + availableBikes.length + " bikes available."); }
			return availableBikes;
		}

		/*
		 *  Function to determine the time to navigate
		 */
		function findRoute(theOrigin, theDestination, mode) {

			return new Promise(function(resolve, reject) {
				// Set the travel mode
				var theMode;
				if (mode == "driving") {
					theMode = google.maps.DirectionsTravelMode.DRIVING;
				} else if (mode == "walking") {
					theMode = google.maps.DirectionsTravelMode.WALKING;
				} else if (mode == "bicycling") {
					theMode = google.maps.DirectionsTravelMode.BICYCLING;
				} else {
					reject("Unknown travel mode.");
				}

				// Create the Google directions request
				var directionsService = new google.maps.DirectionsService();
				var directionsRequest = {
					origin: theOrigin,
					destination: theDestination,
					travelMode: theMode,
					unitSystem: google.maps.UnitSystem.IMPERIAL
				};

				directionsService.route(directionsRequest, function (response, status) {
					if (status == google.maps.DirectionsStatus.OK) {
						if (debugging) {
							console.log("Origin: " + response.routes[0].legs[0].start_address + "\nDestination: " + response.routes[0].legs[0].end_address);
							console.log(response);
						}
						resolve(response.routes[0].legs[0].duration.value);
					} 
					else {
						reject("Could not determine one of the locations.");
					}
				});
			});
		}

		/*
		 *  Function to find the nearest bikes to the lat/long provided.
		 */
		function NearestBike(availableBikes, latitude, longitude) {
			var mindif = 99999;
			var closest;

			for (i = 0; i < availableBikes.length; i++) {
				var dif = PythagorasEquirectangular(latitude, longitude, availableBikes[i].latitude, availableBikes[i].longitude);
				if (dif < mindif) {
					closest = i;
					mindif = dif;
				}
			}
			return availableBikes[closest];
		}

		/*
		 *  Function to convert degrees to radians.
		 */
		function Deg2Rad(deg) {
			return deg * Math.PI / 180;
		}

		/*
		 *  Function to find the Equirectangular triangle (needed for nearest bike function).
		 */
		function PythagorasEquirectangular(lat1, lon1, lat2, lon2) {
			lat1 = Deg2Rad(lat1);
			lat2 = Deg2Rad(lat2);
			lon1 = Deg2Rad(lon1);
			lon2 = Deg2Rad(lon2);
			var R = 6371; // km
			var x = (lon2 - lon1) * Math.cos((lat1 + lat2) / 2);
			var y = (lat2 - lat1);
			var d = Math.sqrt(x * x + y * y) * R;
			return d;
		}
	</script>
</dom-module>
