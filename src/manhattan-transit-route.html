<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="shared-styles.html">
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDTl1JhIHmAfin_kXUBYCnAeIkudpJypcc&libraries=places"></script>

<dom-module id="manhattan-transit-route">
  <template>
    <style include="shared-styles">
      :host {
        display: block;

        padding: 10px;
      }
    </style>
    <div class="card"><paper-input id="origin" label="Starting Location"></paper-input></div>
    <div class="card"><paper-input id="destination" label="Destination"></paper-input></div>
    <br><br>
    <div class="card button-container"><paper-button id="submit" on-click="calculateRoute" raised>Determine Fastest Route</paper-button></div>
  </template>

  <script>
    Polymer({
      is: 'manhattan-transit-route',
      ready: function() {
      	// The following sets up the google autocomplete location fields:
        var originInput = this.$.origin.inputElement;
    	originAutocomplete = new google.maps.places.Autocomplete(originInput);
    	var destinationInput = this.$.destination.inputElement;
    	destinationAutocomplete = new google.maps.places.Autocomplete(destinationInput);
    	var destinationLatLong;
    	var originLatLong;
    	google.maps.event.addListener(originAutocomplete, 'place_changed', function() {
    		var place = originAutocomplete.getPlace();
    		originLatLong = new google.maps.LatLng(place.geometry.location.lat(), place.geometry.location.lng());
    	});
    	google.maps.event.addListener(destinationAutocomplete, 'place_changed', function() {
    		var place = destinationAutocomplete.getPlace();
    		destinationLatLong = new google.maps.LatLng(place.geometry.location.lat(), place.geometry.location.lng());
    	});
      },
      // This function is the function called by the button on the page.
      calculateRoute: function(e) {
      	// Initialize values:
      	var geocoder = new google.maps.Geocoder();
		var originValue = this.$.origin.inputElement.value;
		var destinationValue = this.$.destination.inputElement.value;
		var origin;
		var destination;
		
		// Get available bikes:
		var availableBikes = getBikes();
		if (availableBikes.length == 0) {
			alert("There are currently no bikes available.");
		} 
		
		// Geocode the origin value
		geocoder.geocode( { 'address': originValue}, function(originResults, originStatus) {
			// If the geocode of the origin succeeds
      		if (originStatus == 'OK') {
      			// Set the origin to the geocoded value.
      			origin = originResults[0].geometry.location;
      			// Now Geocode the destination value.
				geocoder.geocode( { 'address': destinationValue }, function(results, status) {
					// If the geocode of the destination succeeds
      				if (status == 'OK') {
      					// Set the destination to the geocoded value
        				destination = results[0].geometry.location;
        				
        				// Now let's find the time it takes to walk to the destination directly.      	   	
      					//var walkingTime = findRoute(new google.maps.LatLng(originLat, originLng), new google.maps.LatLng(destinationLat, destinationLng), "walking");
      					var walkingTime = findRoute(origin, destination, "walking");
      					var bikingTime;
      					// If we have an available bike
      					if (availableBikes.length > 0) {
      						// Let's check which bike is closest to the origin
      						var theNearestBike = NearestBike(availableBikes, origin.lat(), origin.lng());
      						// Create new LatLng with bike's location.
      						var bikeLatLong = new google.maps.LatLng(theNearestBike.latitude,theNearestBike.longitude);
      						console.log(bikeLatLong);
      						bikingTime = findRoute(origin, bikeLatLong , "walking");
      						bikingTime += findRoute(bikeLatLong, destination, "bicycling");
      					}
      					console.log("Walking time: " + walkingTime);
      					console.log("Biking time: " + bikingTime);
      					if (bikingTime < walkingTime) {
      						alert("Biking is faster. Routing you to nearest bike.");
      						window.open("https://www.google.com/maps/dir/" + origin + "/" + bikeLatLong + "/" + destination);
      					} else {
      						alert("Walking is faster. Routing you to destination.");
      						window.open("https://www.google.com/maps/dir/" + origin + "/" + destination);
      					}
      					
      				} else {
      					// Something went wrong geocoding the destination value
        				alert('Destination geocode was not successful: ' + status);
      				}
    			});
      		} else {
      			// Something went wrong geocoding the origin value.
        		alert('Origin geocode was not successful: ' + status);
      		}
    	});
      }
    });

	/*
	 *  Function to get available bikes
	 */
	function getBikes() {
		var bikeRequest = new XMLHttpRequest();
   		bikeRequest.open("GET", "http://129.130.82.141/index.php/api/getLocation", false);
   		bikeRequest.send(null)
   		var bikes = JSON.parse(bikeRequest.responseText);
		
		var availableBikes = [];
		
		bikes.forEach(function(bike) {
			console.log("WARNING: CHECKING FOR TAKEN BIKES (TESTING)");
				if (bike.status == "Taken") {
				availableBikes.push(bike);
			}
		});
		console.log("There are " + availableBikes.length + " bikes available.");
		return availableBikes;
	}

	/*
	 *  Function to determine the time to navigate
	 */
	function findRoute(theOrigin, theDestination, mode) {
		// Set the travel mode
		var theMode;
		if (mode == "driving") {
			theMode = google.maps.DirectionsTravelMode.DRIVING;
		} else if (mode == "walking") {
			theMode = google.maps.DirectionsTravelMode.WALKING;
		} else if (mode == "bicycling") {
			theMode = google.maps.DirectionsTravelMode.BICYCLING;
		} else {
			console.log("Unknown travel mode.");
			return -1;
		}
		
		// Create the Google directions request
		var directionsService = new google.maps.DirectionsService();
		var directionsRequest = {
			origin: theOrigin,
			destination: theDestination,
			travelMode: theMode,
			unitSystem: google.maps.UnitSystem.IMPERIAL
		};
		
		directionsService.route(directionsRequest, function (response, status) {
			if (status == google.maps.DirectionsStatus.OK) {
				console.log("Origin: " + response.routes[0].legs[0].start_address + "\nDestination: " + response.routes[0].legs[0].end_address);
				console.log(response);
				return response.routes[0].legs[0].duration.value;
			} else {
				alert("Could not determine one of the locations.");
				return -1;
			}
		});
	}
	
	function NearestBike(availableBikes, latitude, longitude) {
		var mindif = 99999;
		var closest;

		for (i = 0; i < availableBikes.length; i++) {
			var dif = PythagorasEquirectangular(latitude, longitude, availableBikes[i].latitude, availableBikes[i].longitude);
			if (dif < mindif) {
				closest = i;
				mindif = dif;
			}
		}
		return availableBikes[closest];
	}
	
	function Deg2Rad(deg) {
		return deg * Math.PI / 180;
	}
	
	function PythagorasEquirectangular(lat1, lon1, lat2, lon2) {
		lat1 = Deg2Rad(lat1);
		lat2 = Deg2Rad(lat2);
		lon1 = Deg2Rad(lon1);
		lon2 = Deg2Rad(lon2);
		var R = 6371; // km
		var x = (lon2 - lon1) * Math.cos((lat1 + lat2) / 2);
		var y = (lat2 - lat1);
		var d = Math.sqrt(x * x + y * y) * R;
		return d;
	}
	</script>
</dom-module>
